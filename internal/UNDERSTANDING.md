# Project Understanding

## Core Mission
Create a comprehensive, interactive Claude Code project setup system that establishes professional development infrastructure from day one. The tool transforms empty repositories into production-ready codebases with quality tools, documentation, and AI collaboration patterns.

## Key Philosophy: Prevention Over Cure
Setting up quality infrastructure at project start is exponentially cheaper than retrofitting quality debt later. This tool front-loads the investment in development standards, automated quality checks, and structured workflows.

## Architecture Overview

### Interactive Setup System
- **4 Core Questions** determine entire setup: project type, quality level, team size, CI/CD
- **3 Modes**: Full setup, codebase recovery, GitHub Codespaces DevContainer
- **Language-Agnostic Patterns**: Same documentation and command structure across all languages

### Quality Infrastructure Layers
1. **Foundation**: Git repository, .gitignore, basic project structure
2. **Language Tools**: ESLint, Prettier, Jest (JS), Ruff (Python), etc.
3. **Documentation**: CLAUDE.md, ACTIVE_WORK.md, README.md templates
4. **Custom Commands**: 19 specialized commands for structured development
5. **Utility Libraries**: Shared code for maintenance and documentation sync

### Command System Architecture
- **19 Core Commands**: `/hygiene`, `/todo`, `/commit`, `/design`, `/estimate`, etc.
- **Recovery Commands**: `/recovery-assess`, `/recovery-plan`, `/recovery-execute`
- **Maintenance Commands**: `/update-docs`, `/ideation`, `/reflect`
- **YAML Frontmatter**: Structured metadata for allowed-tools and descriptions

## Technical Implementation

### ES Module Migration
- **Problem**: ERR_REQUIRE_ESM errors with modern dependencies
- **Solution**: Full conversion to ES modules with Jest configuration updates
- **Testing**: Conditional CLI execution to prevent side effects during imports

### AST-Based Code Analysis
- **Framework**: Babel parser for JavaScript/TypeScript analysis
- **Features**: Complexity calculation, insight generation, development suggestions
- **Extensibility**: Designed for multi-language support (Python, Go, Rust planned)

### Claude Usage Estimation
- **Cost Model**: Token-based estimation for different task types
- **Usage Patterns**: Light (10-50), Moderate (50-150), Heavy (150-400), Intensive (400+)
- **Integration**: Built into `/estimate` command and project templates

### Documentation Synchronization
- **Automated Updates**: README.md stays current with actual command count
- **Template System**: Consistent documentation structure across all languages
- **Maintenance Scripts**: NPM scripts for documentation upkeep

## Dogfooding Principle Implementation

### Core Concept
Every improvement to this repository propagates to projects generated by the tool. If a feature is valuable enough for our internal development, users deserve the same capability.

### Current Implementation Status
- ‚úÖ **Custom Commands**: All 19 commands installed in generated projects
- ‚úÖ **Quality Infrastructure**: Templates match our internal setup
- ‚úÖ **Documentation Sync**: Utilities and commands for README maintenance
- ‚úÖ **Claude Integration**: Usage estimation and collaboration guidelines
- üöß **Test Infrastructure**: ES module Jest setup partially propagated
- ‚ùå **Advanced Workflows**: Some internal patterns not yet templated

### Template System
- **`templates/`**: Directory structure for generated project files
- **Variable Substitution**: `{{QUALITY_LEVEL}}`, `{{TEAM_SIZE}}`, etc.
- **Utility Libraries**: Shared code copied to generated projects
- **Command Templates**: Consistent command structure across projects

## Project Structure Analysis

### Key Files
- **`bin/cli.js`**: Main entry point, interactive setup flow
- **`lib/languages/`**: Language-specific setup modules
- **`lib/claude-estimator.js`**: Claude usage cost calculation
- **`lib/readme-updater.js`**: Documentation synchronization utilities
- **`lib/code-analysis.js`**: AST-based code analysis framework
- **`templates/`**: Template files for generated projects
- **`.claude/commands/`**: Command definitions and templates

### Quality Standards
- **Complexity**: <15 per function, <400 lines per file
- **Testing**: ES modules with Jest, working test infrastructure
- **Documentation**: Self-updating README, comprehensive command documentation
- **Git Integration**: Automatic initial commits, proper co-authoring

## Development Insights

### Empty Repository Support
Critical insight: Tool must work for completely empty repositories. Many projects start from nothing, requiring:
- Minimal project structure creation
- Language detection and setup
- Quality infrastructure before any application code
- Documentation templates as foundation

### Universal Patterns
Same quality principles apply across all languages:
- Linting and formatting tools
- Test infrastructure setup
- Documentation standards
- Git workflow patterns
- Claude collaboration guidelines

### Interactive Over Manual
Conversational setup scales better than complex written instructions. 4 questions determine entire project configuration, making setup accessible while maintaining comprehensive coverage.

## Current State Assessment

### Strengths
- Comprehensive quality infrastructure setup
- Strong dogfooding principle implementation
- Multi-language support with consistent patterns
- Interactive setup experience
- Robust command system with 19 specialized commands

### Areas for Improvement
- ESLint configuration conflicts with ES modules
- Tree-sitter dependencies for advanced AST analysis
- Template testing framework needed
- Plugin architecture for advanced features
- User feedback loop from generated projects

### Next Development Priorities
1. **Test Infrastructure**: Ensure generated projects have working tests
2. **Advanced AST Analysis**: Resolve tree-sitter dependency issues
3. **Template Validation**: Automated testing of generated project quality
4. **Plugin Architecture**: Support for advanced/custom features
5. **User Feedback**: Mechanism for improvements from generated projects

## Key Learnings

### Technical
- ES module conversion requires careful Jest configuration
- CLI side effects must be prevented during import for testing
- AST analysis provides valuable development insights
- Documentation synchronization prevents command count drift

### Product
- Prevention architecture is exponentially cheaper than reactive fixes
- Interactive setup democratizes complex configuration
- Dogfooding ensures tool quality matches user expectations
- Universal patterns reduce cognitive load across languages

### Process
- Quality infrastructure should be established before application code
- Automated documentation maintenance is essential for accuracy
- Command-driven development enables consistent Claude interaction
- Template systems must be validated with real project generation

---

*Last Updated: 2025-01-05*
*This understanding evolves as the project develops. Regular updates capture new insights and architectural decisions.*